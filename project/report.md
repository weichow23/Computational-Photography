<center>
  <font face="é»‘ä½“" size = 6>
    äº¤äº’å¼æ•°å­—è’™å¤ªå¥‡
  </font>
  <center><font face="é»‘ä½“" size = 4>
    å§“åï¼š å‘¨ç‚œ
  </font>
  <center><font face="é»‘ä½“" size = 4>
    å­¦å·ï¼š 3210103790
  </font>
</center> 

[TOC]

## ä¸€ã€ äº¤äº’å¼æ•°å­—è’™å¤ªå¥‡æ•ˆæœæ¦‚è¿°

äº¤äº’å¼æ•°å­—è’™å¤ªå¥‡æ˜¯ä¸€ç§åˆ›æ–°çš„å›¾åƒå¤„ç†æŠ€æœ¯ï¼Œæœ€æ—©åœ¨è®ºæ–‡ [[1]]((https://grail.cs.washington.edu/projects/photomontage/photomontage.pdf)) ä¸­è¢«å¼•å…¥ã€‚è¯¥æŠ€æœ¯å¯ä»¥ä»¥ä¸€ç§éš¾ä»¥å¯Ÿè§‰çš„æ–¹å¼å°†å¤šå¼ ç…§ç‰‡èåˆåœ¨ä¸€èµ·ï¼Œä»è€Œäº§ç”Ÿä»¤äººæƒŠå¹çš„çœŸå®å›¾åƒèåˆæ•ˆæœã€‚

åœ¨äº¤äº’å¼æ•°å­—è’™å¤ªå¥‡ä¸­ï¼Œç³»ç»Ÿé€šè¿‡ç”¨æˆ·çš„è¾“å…¥å’Œç”»ç¬”æ“ä½œï¼Œå°†æ ‡ç­¾(label)åº”ç”¨åˆ°æ¯å¼ ç…§ç‰‡ä¸Šã€‚ç”¨æˆ·å¯ä»¥ä½¿ç”¨ç”»ç¬”åœ¨ç…§ç‰‡ä¸Šæ ‡è®°æ„Ÿå…´è¶£çš„åŒºåŸŸï¼ŒæŒ‡å®šä¸åŒçš„æ ‡ç­¾ã€‚ç³»ç»Ÿæ ¹æ®è¿™äº›ç”¨æˆ·æŒ‡å®šçš„æ ‡ç­¾ä»¥åŠå›¾åƒä¸­çš„é¢œè‰²ä¿¡æ¯ï¼Œæ¥ç”Ÿæˆæœ€ç»ˆçš„èåˆç»“æœã€‚

ä¾‹å¦‚ï¼Œè€ƒè™‘ä¸‹å›¾ä¸­çš„ç¤ºä¾‹ã€‚å·¦ä¾§å±•ç¤ºäº†å››å¼ ä¸åŒçš„ç…§ç‰‡ï¼Œè€Œä¸­é—´çš„å›¾åƒæ˜¾ç¤ºäº†ç”¨æˆ·è¿›è¡Œäººå·¥äº¤äº’çš„ç»“æœï¼Œå³ç”¨æˆ·ç”¨ç”»ç¬”åœ¨æ¯å¼ ç…§ç‰‡ä¸Šæ ‡è®°äº†ä¸åŒçš„åŒºåŸŸã€‚é€šè¿‡ç»“åˆç”¨æˆ·æ ‡è®°çš„æ ‡ç­¾å’Œæ¯ä¸ªåŒºåŸŸçš„é¢œè‰²ä¿¡æ¯ï¼Œç³»ç»Ÿç”Ÿæˆäº†å³ä¾§å±•ç¤ºçš„èåˆæ•ˆæœã€‚è¿™ç§æŠ€æœ¯å¯ä»¥äº§ç”Ÿé€¼çœŸçš„å›¾åƒèåˆï¼Œä½¿å¾—å¤šå¼ ç…§ç‰‡ä»¥ä¸€ç§æ— ç¼ã€è‡ªç„¶çš„æ–¹å¼èåˆåœ¨ä¸€èµ·ã€‚

äº¤äº’å¼æ•°å­—è’™å¤ªå¥‡æŠ€æœ¯çš„åº”ç”¨éå¸¸å¹¿æ³›ï¼Œä¾‹å¦‚åœ¨æ•°å­—è‰ºæœ¯ã€è™šæ‹Ÿç°å®ã€è§†é¢‘åˆ¶ä½œç­‰é¢†åŸŸéƒ½æœ‰é‡è¦çš„åº”ç”¨ã€‚å®ƒä½¿ç”¨æˆ·èƒ½å¤Ÿä»¥äº¤äº’çš„æ–¹å¼å‚ä¸åˆ°å›¾åƒèåˆçš„è¿‡ç¨‹ä¸­ï¼Œä»è€Œå®ç°æ›´åŠ ä¸ªæ€§åŒ–å’Œç²¾ç¡®çš„å›¾åƒåˆæˆã€‚è¯¥æŠ€æœ¯çš„å‘å±•ä¸ºæˆ‘ä»¬æä¾›äº†åˆ›é€ å‡ºæ›´å…·åˆ›æ„å’Œé€¼çœŸåº¦çš„å›¾åƒèåˆæ•ˆæœçš„æœºä¼šã€‚æœ¬è¯¾ç¨‹ä½œä¸šä¸»è¦å¯¹è¯¥æŠ€æœ¯è¿›è¡Œäº†å®ç°ã€‚![](fig/01.png)

## äºŒã€ç®—æ³•åŸç†ä¸å®ç°

### 2.1 ç®—æ³•æµç¨‹

æ•´ä¸ªç®—æ³•çš„æµç¨‹å¤§è‡´å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

<img src="fig/02.png" style="zoom:45%;" />

æœ€åˆï¼Œç¬¬ä¸€å¼ æºå›¾åƒè¢«ç”¨ä½œå½“å‰çš„åˆæˆå›¾åƒï¼Œå¹¶è¿›è¡Œæ ‡è®°ï¼ˆæ ‡è®°æ˜¾ç¤ºåœ¨åˆæˆå›¾åƒä¸‹æ–¹ï¼‰ã€‚åˆå§‹æ—¶ï¼Œæ ‡è®°åœ¨æ•´ä¸ªå›¾åƒä¸Šä¿æŒæ’å®šï¼Œå› ä¸ºåˆæˆå›¾åƒçš„æ‰€æœ‰åƒç´ éƒ½æ¥è‡ªåŒä¸€å¼ æºå›¾åƒã€‚ç„¶åï¼Œç”¨æˆ·é€šè¿‡ä½¿ç”¨å•å›¾åƒç”»ç¬”ä»¥ä¸åŒçš„å›¾åƒç›®æ ‡è¿›è¡Œè¿­ä»£ç»˜ç”»ï¼Œä¿®æ”¹å½“å‰çš„åˆæˆå›¾åƒå’Œæ ‡è®°ã€‚æœ€åï¼Œåº”ç”¨æ¢¯åº¦åŸŸèåˆä»¥æ¶ˆé™¤ä»»ä½•å‰©ä½™å¯è§çš„æ¥ç¼ã€‚

è¦å®ç°ä¸Šè¿°çš„ä¸¤ä¸ªåŠŸèƒ½ï¼ŒåŒ…å«ä¸¤ä¸ªé‡è¦çš„æŠ€æœ¯**Graph-cut optimization**å’Œ**Gradient-domain fusion**ï¼Œ ä¹Ÿå°±æ˜¯è®ºæ–‡ä¸­çš„ç¬¬3å’Œç¬¬4èŠ‚çš„å†…å®¹ï¼Œä¸‹åˆ—æˆ‘è®²å°†è¿›è¡Œç®€å•çš„ä»‹ç»å¹¶ä¸”è°ˆä¸€è°ˆæˆ‘çš„ç†è§£ã€‚

### 2.2 æ€»èƒ½é‡å‡½æ•°

å¯¹äºè¾“å…¥å›¾åƒï¼Œä¸ºäº†å¾—åˆ°åˆæˆçš„å›¾åƒï¼Œå‚è€ƒåŸè®ºæ–‡ï¼Œæˆ‘ä»¬å…ˆå®šä¹‰æœ¬å®éªŒä¸­éœ€è¦ä¼˜åŒ–çš„èƒ½é‡å‡½æ•°ã€‚

å‡è®¾æˆ‘ä»¬æœ‰$n$ä¸ªæºå›¾åƒ$S_1, ..., S_n$ã€‚ä¸ºäº†å½¢æˆä¸€ä¸ªåˆæˆå›¾åƒï¼Œæˆ‘ä»¬å¿…é¡»ä¸ºæ¯ä¸ªåƒç´ $p$é€‰æ‹©ä¸€ä¸ªæºå›¾åƒ$S_i$ã€‚æˆ‘ä»¬å°†åƒç´ å’Œæºå›¾åƒä¹‹é—´çš„æ˜ å°„ç§°ä¸ºæ ‡è®°(labeling)ï¼Œå¹¶ç”¨$L(p)$è¡¨ç¤ºæ¯ä¸ªåƒç´ çš„æ ‡è®°ã€‚å¦‚æœåœ¨åˆæˆå›¾åƒä¸­ç›¸é‚»çš„åƒç´ $p$å’Œ$q$å…·æœ‰ä¸åŒçš„æ ‡è®°ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºæ¥ç¼(seam)ã€‚

åŸè®ºæ–‡ä¸­ä½¿ç”¨**"alpha expansion"ç®—æ³•**æ¥æœ€å°åŒ–æˆæœ¬å‡½æ•°ã€‚**"alpha expansion"ç®—æ³•**çš„å†…éƒ¨å¾ªç¯çš„ç¬¬$t$æ¬¡è¿­ä»£å°†ç‰¹å®šçš„æ ‡è®°$Î±$å’Œå½“å‰çš„æ ‡è®°$L_t$ä½œä¸ºè¾“å…¥ï¼Œå¹¶è®¡ç®—ä¸€ä¸ªæœ€ä¼˜æ ‡è®°$L_{t+1}$ï¼Œä½¿å¾—$L_{t+1}(p) = L_t(p)$æˆ–$L_{t+1}(p) = Î±$ã€‚å¤–éƒ¨å¾ªç¯éå†æ¯ä¸ªå¯èƒ½çš„æ ‡è®°ã€‚å½“å¯¹æ‰€æœ‰æ ‡è®°è¿›è¡Œçš„ä¸€æ¬¡è¿­ä»£æ— æ³•å‡å°‘æˆæœ¬å‡½æ•°æ—¶ï¼Œç®—æ³•ç»ˆæ­¢ã€‚å¦‚æœæˆæœ¬å‡½æ•°æ˜¯ä¸€ä¸ªåº¦é‡å‡½æ•°ï¼Œé‚£ä¹ˆè®¡ç®—å¾—åˆ°çš„æ ‡è®°ä¿è¯åœ¨å…¨å±€æœ€å°å€¼çš„ä¸¤å€èŒƒå›´å†…ã€‚

åœ¨æˆ‘ä»¬çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†åƒç´ æ ‡è®°Lçš„æˆæœ¬å‡½æ•°$C$å®šä¹‰ä¸ºä¸¤ä¸ªé¡¹çš„æ€»å’Œï¼šå¯¹æ‰€æœ‰åƒç´ $p$çš„æ•°æ®æƒ©ç½šé¡¹$C_d$å’Œå¯¹æ‰€æœ‰ç›¸é‚»åƒç´ $p$ã€$q$å¯¹çš„äº¤äº’æƒ©ç½šé¡¹$C_i$ï¼š
$$
C(L) = \sum\limits_p^{} {{C_d}(p,L(p))}  + \sum\limits_{p,q}^{} {{C_i}(p,q,L(p),L(q))}
$$
å…¶ä¸­$C_d(p)$è¡¨ç¤ºåƒç´ $p$çš„æ•°æ®æƒ©ç½šï¼Œ$C_i(p, q)$è¡¨ç¤ºç›¸é‚»åƒç´ $p$å’Œ$q$ä¹‹é—´çš„äº¤äº’æƒ©ç½šã€‚

å¯¹äºæˆ‘ä»¬çš„åº”ç”¨ç¨‹åºï¼Œæ¯”è¾ƒé‡è¦çš„æ¦‚å¿µæ˜¯**data term** å’Œ **smooth term**ã€‚æ•°æ®æƒ©ç½šç”±ä¸å›¾åƒç›®æ ‡çš„è·ç¦»å®šä¹‰ï¼Œè€Œäº¤äº’æƒ©ç½šç”±ä¸æ¥ç¼ç›®æ ‡çš„è·ç¦»å®šä¹‰ã€‚å…·ä½“è€Œè¨€ï¼Œæˆ‘ä»¬æŒ‰ç…§ç”¨æˆ·é€‰æ‹©çš„æ–¹å¼æ¥å®šä¹‰æ•°æ®æƒ©ç½šé¡¹$C_d(p, L(p))$ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

- æŒ‡å®šé¢œè‰² **Designated color (most or least similar)**ï¼šæºå›¾åƒåƒç´ $S_{L(p)} (p)$åœ¨RGBç©ºé—´ä¸­ä¸ç”¨æˆ·æŒ‡å®šçš„ç›®æ ‡é¢œè‰²ä¹‹é—´çš„æ¬§æ°è·ç¦»ã€‚æˆ‘ä»¬æä¾›äº†ä¸€ä¸ªç”¨æˆ·ç•Œé¢ï¼Œç”¨äºé€‰æ‹©ç”¨ä½œé¢œè‰²ç›®æ ‡çš„åƒç´ ã€‚
- äº®åº¦ **Minimum (maximum) luminance**ï¼šä¸åƒç´ èŒƒå›´ä¸­æœ€å°ï¼ˆæœ€å¤§ï¼‰äº®åº¦åƒç´ çš„äº®åº¦å·®è·ã€‚
- å¯èƒ½æ€§ **Minimum (maximum) likelihood**ï¼šç»™å®šä»åƒç´ èŒƒå›´ä¸­çš„æ‰€æœ‰åƒç´ çš„é¢œè‰²ç›´æ–¹å›¾å½¢æˆçš„æ¦‚ç‡åˆ†å¸ƒå‡½æ•°ï¼Œè®¡ç®—æºå›¾åƒåƒç´ $S_{L(p)} (p)$çš„é¢œè‰²çš„æ¦‚ç‡ï¼ˆæˆ–æ¦‚ç‡çš„è¡¥ï¼‰ã€‚é¢œè‰²ç›´æ–¹å›¾é’ˆå¯¹ä¸‰ä¸ªé¢œè‰²é€šé“åˆ†åˆ«è¿›è¡Œç›´æ–¹å›¾åŒ–ï¼Œä½¿ç”¨$20$ä¸ªåŒºé—´è¿›è¡Œåˆ’åˆ†ï¼Œå¹¶å°†å®ƒä»¬è§†ä¸ºç‹¬ç«‹çš„éšæœºå˜é‡ã€‚
- æ©¡çš®æ“¦ï¼šæºå›¾åƒåƒç´ $S_{L(p)} (p)$åœ¨RGBç©ºé—´ä¸­ä¸å½“å‰åˆæˆé¢œè‰²ä¹‹é—´çš„æ¬§æ°è·ç¦»ã€‚
- å·®å¼‚ï¼šæºå›¾åƒåƒç´ $S_{L(p)} (p)$ä¸ç”¨æˆ·æŒ‡å®šçš„æºå›¾åƒ$S_u$çš„åƒç´ $S_u(p)$ä¹‹é—´åœ¨RGBç©ºé—´ä¸­çš„æ¬§æ°è·ç¦»ã€‚
- æŒ‡å®šå›¾åƒï¼šå¦‚æœ$L(p) = u$ï¼Œå…¶ä¸­$S_u$æ˜¯ç”¨æˆ·æŒ‡å®šçš„æºå›¾åƒï¼Œåˆ™ä¸º$0$ï¼›å¦åˆ™ä¸ºä¸€ä¸ªè¾ƒå¤§çš„æƒ©ç½šã€‚
- å¯¹æ¯”åº¦ï¼šé€šè¿‡ä»ä¸åŒå°ºåº¦è®¡ç®—çš„ä¸¤ä¸ªé«˜æ–¯æ¨¡ç³Šæ ¸çš„å·ç§¯ç›¸å‡å¾—åˆ°çš„åº¦é‡ã€‚

æœ€ç»ˆæˆ‘ä»¬å¯ä»¥å¾—åˆ°å¦‚ä¸‹çš„æ•°æ®é¡¹å’Œå¹³æ»‘é¡¹çš„å®šä¹‰ã€‚

æˆ‘ä»¬å°†æ¥ç¼ç›®æ ‡å®šä¹‰ä¸ºå¦‚æœ$L(p) = L(q)$ï¼Œåˆ™ä¸º0ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬å°†ç›®æ ‡å®šä¹‰ä¸ºï¼š

data termçš„å®šä¹‰å¦‚ä¸‹ï¼š
$$
{C_d}(p,L(p)) = \left\{ {\begin{array}{*{20}{c}}
0&{L(p) = u}\\
{\text{large penalty}}&\text{otherwise}
\end{array}} \right.
$$
smooth termçš„å®šä¹‰å¦‚ä¸‹ï¼š
$$
{C_i}(p,q,L(p),L(q)) = \left\{ {\begin{array}{*{20}{c}}
X&\text{if matching "colors"}\\
Y&\text{if matching "gradients"}\\
{X + Y}&\text{if matching "colors \& gradients"}\\
{X/Z}&\text{if matching "colors \& edges"}
\end{array}} \right.
$$
å…¶ä¸­
$$
X=||S_{L(p)}(p)-S_{L(q)}(p)|| + ||S_{L(p)}(q)-S_{L(q)}(q)|| \\
Y=||\nabla S_{L(p)}(p)- \nabla S_{L(q)}(p)|| + ||\nabla S_{L(p)}(q)- \nabla S_{L(q)}(q)|| \\
Z=E_{L(p)}(p,q) + E_{L(q)}(p,q)
$$
å…¶ä¸­$âˆ‡S_z(p)$æ˜¯å›¾åƒzåœ¨åƒç´ på¤„çš„6åˆ†é‡é¢œè‰²æ¢¯åº¦ï¼Œ$E_z(p, q)$æ˜¯å›¾åƒ$z$çš„ä¸¤ä¸ªç›¸é‚»åƒç´ $p$å’Œ$q$ä¹‹é—´çš„è¾¹ç¼˜åŠ¿èƒ½ï¼Œä½¿ç”¨Sobelæ»¤æ³¢å™¨è®¡ç®—è€Œå¾—ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ‰€æœ‰è¿™äº›æ¥ç¼ç›®æ ‡éƒ½æ˜¯åº¦é‡å‡½æ•°ï¼Œé™¤äº†$X/Z$ï¼Œå®ƒæ˜¯ä¸€ä¸ªåŠåº¦é‡å‡½æ•°ï¼Œå› ä¸ºå®ƒå¹¶ä¸æ€»æ˜¯æ»¡è¶³ä¸‰è§’ä¸ç­‰å¼ã€‚å½“ä½¿ç”¨è¿™ç§æ¥ç¼æƒ©ç½šæ—¶ï¼Œè®¸å¤š"alpha expansion"ç®—æ³•çš„ç†è®ºä¿è¯éƒ½ä¼šä¸§å¤±ã€‚

æœ€åï¼Œå‰ä¸€èŠ‚ä¸­æè¿°çš„"æƒ¯æ€§"æ§åˆ¶æ˜¯é€šè¿‡è®¡ç®—è¿‘ä¼¼æ¬§æ°è·ç¦»å›¾$D(p)$æ¥å®ç°çš„ï¼Œè¯¥å›¾æè¿°äº†æ¯ä¸ªç‚¹$p$å¤„ç¦»ç»˜åˆ¶åŒºåŸŸçš„è·ç¦»ï¼ˆè¯¥è·ç¦»åœ¨åŒºåŸŸå†…ä¸º0ï¼‰ã€‚åœ¨å›¾å‰²ä¼˜åŒ–ä¸­ï¼Œæ¯å½“$L_{t+1}(p)  = L_t(p)$æ—¶ï¼Œè¿™ä¸ªè·ç¦»çš„åŠ æƒç‰ˆæœ¬å°†è¢«æ·»åŠ åˆ°è¢«æœ€å°åŒ–çš„æ•´ä½“æˆæœ¬å‡½æ•°ä¸­ã€‚æƒ¯æ€§è¶Šé«˜ï¼Œå›¾å‰²åœ¨è¿œç¦»ç»˜åˆ¶åŒºåŸŸçš„åŒºåŸŸé€‰æ‹©æ–°æ ‡ç­¾çš„å¯èƒ½æ€§å°±è¶Šå°ã€‚

### 2.3 Graph-cut Optimization

#### 2.3.1 Markov Random Field

å·²ç»çŸ¥é“äº†ä¸Šè¿°çš„èƒ½é‡å‡½æ•°ä¹‹åï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯ä¼˜åŒ–ï¼ˆå³æœ€å°åŒ–ï¼‰ä¸Šè¿°çš„å‡½æ•°ï¼Œä»è€Œæ±‚å‡ºæœ€ä½³çš„è§£ï¼ˆåœ¨æœ¬å®éªŒä¸­è§£å³æ˜¯æ¯ä¸ªåƒç´ çš„labelï¼‰ã€‚æ±‚è§£èƒ½é‡å‡½æ•°æœ¬è´¨æ˜¯é©¬å°”å¯å¤«éšæœºåœºé—®é¢˜ï¼ˆMarkov Random Fieldï¼‰ï¼Œå³MRFé—®é¢˜ï¼Œå®ƒæ˜¯ä¸€ç§ç”¨äºå»ºæ¨¡å’Œè§£å†³æ¦‚ç‡å›¾æ¨¡å‹ä¸­çš„ä¼˜åŒ–é—®é¢˜çš„æ–¹æ³•ã€‚åœ¨ç»™å®šä¸€ç»„è§‚æµ‹å€¼çš„æƒ…å†µä¸‹ï¼ŒMRFç”¨äºä¼°è®¡æœªè§‚æµ‹åˆ°çš„å˜é‡çš„çŠ¶æ€ã€‚

ä¸ºäº†è§£å†³è¿™ä¸ªä¼˜åŒ–é—®é¢˜ï¼Œæ–‡æœ¬ä¸­æåˆ°ä½¿ç”¨äº†å›¾å‰²ï¼ˆgraph cutï¼‰ä¼˜åŒ–æ–¹æ³•ã€‚å›¾å‰²æ˜¯ä¸€ç§åœ¨å›¾ä¸Šè¿›è¡Œä¼˜åŒ–çš„æŠ€æœ¯ï¼Œå®ƒé€šè¿‡å°†å›¾åˆ’åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†æ¥æœ€å°åŒ–åˆ‡å‰²æˆæœ¬ã€‚åœ¨è¿™ä¸ªåœºæ™¯ä¸‹ï¼Œå›¾çš„èŠ‚ç‚¹è¡¨ç¤ºåƒç´ ï¼Œè¾¹è¡¨ç¤ºåƒç´ ä¹‹é—´çš„å…³ç³»ï¼Œé€šè¿‡æœ€å°åŒ–èƒ½é‡å‡½æ•°æ¥è·å¾—æœ€ä¼˜çš„åˆ‡å‰²ï¼Œå³æ¯ä¸ªåƒç´ çš„æœ€ä¼˜æ ‡ç­¾ã€‚

è¯¾ç¨‹é¡¹ç›®ä»‹ç»çš„é¡µé¢ä¸­ï¼ŒåŠ©æ•™æ¨èäº†ä½¿ç”¨[gco-v3.0åº“](http://vision.csd.uwo.ca/code/gco-v3.0.zip), ä½†æ˜¯æˆ‘å½“æ—¶è¿™ä¸ªåº“æ­»æ´»å’Œæœ¬åœ°çš„ç¯å¢ƒå†²çªï¼Œæˆ‘æœ€åé‡‡ç”¨äº†pythonæ¥è¿›è¡Œå®ç°ï¼Œæˆ‘æ²¡æœ‰æ‰¾åˆ°gcoçš„pythonç‰ˆæœ¬ï¼Œæœ€åé€‰æ‹©é‡‡ç”¨äº†ICCC2005ä¸­çš„è®ºæ–‡[Efficiently Solving Dynamic Markov Random Fields Using Graph Cuts.](https://ieeexplore.ieee.org/abstract/document/1544820/)çš„æ–¹æ³•è¿›è¡Œæ±‚è§£MRFé—®é¢˜, å…·ä½“æ¥è¯´è¯¥æ–¹æ³•å·²ç»å®ç°åœ¨äº†pythonçš„`maxflow`åº“ä¸­ã€‚

åœ¨å›¾å‰²é˜¶æ®µï¼Œæˆ‘ä»¬ä½¿ç”¨äº†"æŒ‡å®šå›¾åƒ"æ•°æ®æƒ©ç½šå’Œ"é¢œè‰²"äº¤äº’æƒ©ç½šã€‚å¹¶ä¸”ï¼Œæˆ‘ä½¿ç”¨äº†alpha-betaäº¤æ¢ä»£æ›¿äº†åŸæœ‰è®ºæ–‡ä¸­æåˆ°çš„alphaæ‰©å±•ã€‚å…·ä½“å®ç°åœ¨`mantage.py`æ–‡ä»¶ä¸­çš„`alpha_beta_swap`å‡½æ•°ï¼Œå…·ä½“çš„è§£æå¦‚ä¸‹ã€‚

å‡½æ•°é¦–å…ˆè·å–compositeå›¾åƒçš„é«˜åº¦ï¼ˆhï¼‰å’Œå®½åº¦ï¼ˆwï¼‰ï¼Œå¹¶åˆå§‹åŒ–ä¸€ä¸ªæœ€å¤§æµå›¾ï¼ˆgraphï¼‰ï¼Œç”¨äºå­˜å‚¨èŠ‚ç‚¹å’Œè¾¹ã€‚å›¾çš„èŠ‚ç‚¹æ•°é‡ä¸ºh * wï¼Œè¾¹çš„æ•°é‡ä¸º2 * ((h - 1) * w + (w - 1) * h)ï¼Œè¿™æ ·ç¡®ä¿æœ‰è¶³å¤Ÿçš„ç©ºé—´æ¥å­˜å‚¨èŠ‚ç‚¹å’Œè¾¹ã€‚æˆ‘ä»¬éšååœ¨è¯¥å›¾ä¸­å¼•å…¥æ•°æ®é¡¹å’Œå¹³æ»‘é¡¹çº¦æŸã€‚

```python
def alpha_beta_swap(composite, source, composite_mask, source_mask):
    '''
    Perform alpha-beta swap maxflow for the current composite and source images.

    Args:
        composite (np.ndarray): The composite image.
        source (np.ndarray): The source image.
        composite_mask (np.ndarray): The mask for the composite image.
        source_mask (np.ndarray): The mask for the source image.

    Returns:
        np.ndarray: The label map after the alpha-beta swap.
    '''
    h, w, _ = composite.shape
    graph = maxflow.Graph[int](h * w, 2 * ((h - 1) * w + (w - 1) * h))
    nodeids = graph.add_grid_nodes((h, w))
```

#### 2.3.2 Smooth Term

smooth termç”¨äºåº¦é‡ç›¸é‚»åƒç´ ä¹‹é—´æ ‡ç­¾ä¸ä¸€è‡´çš„æƒ©ç½šã€‚å¹³æ»‘é¡¹æƒ©ç½šç”¨äºä¿è¯ç›¸é‚»åƒç´ ä¹‹é—´çš„æ ‡ç­¾ä¸€è‡´æ€§ï¼Œé¿å…è¿‡å¤§çš„æ ‡ç­¾è·³å˜ï¼Œä»è€Œå¾—åˆ°æ›´å¹³æ»‘çš„åˆ†å‰²ç»“æœ.æ ¹æ®ç»™å®šçš„å…¬å¼æˆ‘ä»¬å¯ä»¥è§£é‡Šä¸ºï¼š

- å¦‚æœç›¸é‚»åƒç´ på’Œqçš„é¢œè‰²åŒ¹é…ï¼Œæƒ©ç½šä¸ºXã€‚
- å¦‚æœç›¸é‚»åƒç´ på’Œqçš„æ¢¯åº¦åŒ¹é…ï¼Œæƒ©ç½šä¸ºYã€‚
- å¦‚æœé¢œè‰²å’Œæ¢¯åº¦éƒ½åŒ¹é…ï¼Œæƒ©ç½šä¸ºX + Yã€‚
- å¦‚æœé¢œè‰²å’Œè¾¹ç¼˜åŒ¹é…ï¼Œæƒ©ç½šä¸ºX / Zã€‚

å…·ä½“çš„ä»£ç å®ç°å¦‚ä¸‹ï¼š

```python
# Calculate the color differences between adjacent pixels for n-links
color_diff_x = np.sum(np.abs(composite[:, :-1] - source[:, 1:]), axis=-1)
color_diff_y = np.sum(np.abs(composite[:-1, :] - source[1:, :]), axis=-1)

# Add edges for horizontally adjacent pixels
horizontal_structure = np.array([[0, 0, 0],
                                 [0, 0, 1],
                                 [0, 0, 0]])
graph.add_grid_edges(nodeids[:, :-1], color_diff_x, horizontal_structure, symmetric=True)

# Add edges for vertically adjacent pixels
vertical_structure = np.array([[0, 0, 0],
                               [0, 0, 0],
                               [0, 1, 0]])
graph.add_grid_edges(nodeids[:-1, :], color_diff_y, vertical_structure, symmetric=True)
```

- `color_diff_x` å’Œ `color_diff_y` åˆ†åˆ«è®¡ç®—æ°´å¹³å’Œå‚ç›´æ–¹å‘ä¸Šç›¸é‚»åƒç´ çš„é¢œè‰²å·®å¼‚ï¼Œç”¨äºå®šä¹‰n-linksçš„å®¹é‡ã€‚
- `add_grid_edges` æ–¹æ³•ç”¨äºåœ¨å›¾ä¸­æ·»åŠ æ°´å¹³å’Œå‚ç›´ç›¸é‚»åƒç´ ä¹‹é—´çš„è¾¹ï¼Œè¡¨ç¤ºå¹³æ»‘é¡¹ã€‚

#### 2.3.3 Data Term

data termç”¨äºåº¦é‡æ¯ä¸ªåƒç´ å±äºæŸä¸ªæ ‡ç­¾ï¼ˆåœ¨è¿™é‡Œæ˜¯compositeæˆ–sourceï¼‰çš„é€‚åˆåº¦ã€‚æ•°æ®é¡¹æƒ©ç½šç”¨äºä¿è¯æ¯ä¸ªåƒç´ æ›´ç¬¦åˆå®ƒæ‰€å±çš„æ©ç ï¼ˆsourceæˆ–compositeï¼‰ã€‚æ ¹æ®ç»™å®šçš„å…¬å¼æˆ‘ä»¬çŸ¥é“ï¼š

- å¦‚æœåƒç´ pçš„æ ‡ç­¾L(p)ä¸ç»™å®šçš„æ ‡ç­¾uç›¸åŒï¼Œåˆ™æ•°æ®é¡¹æƒ©ç½šä¸º0ã€‚
- å¦åˆ™ï¼Œæ•°æ®é¡¹æƒ©ç½šæ˜¯ä¸€ä¸ªéå¸¸å¤§çš„å€¼ã€‚

åœ¨graphä¸­çš„çº¦æŸå¯ä»¥è¡¨ç¤ºä¸ºå¦‚ä¸‹ä»£ç ï¼š

```python
# Add terminal edges
# Alpha is 0 (label for composite), beta is 1 (label for source)
alpha_weight = source_mask.astype(np.int64) * scale
beta_weight = composite_mask.astype(np.int64) * scale
graph.add_grid_tedges(nodeids, alpha_weight, beta_weight)
```

- `source_mask`è¡¨ç¤ºæºå›¾åƒçš„æ©ç ï¼Œå…¶å¯¹åº”çš„åƒç´ æ ‡ç­¾ä¸º1ã€‚å¦‚æœæ ‡ç­¾ä¸ºsourceï¼ˆ1ï¼‰ï¼Œåˆ™æ•°æ®é¡¹æƒ©ç½šä¸º0ï¼Œä¹˜ä»¥ä¸€ä¸ªå¤§çš„å¸¸æ•°`scale`åè¿˜æ˜¯0ã€‚
- `composite_mask`è¡¨ç¤ºç»„åˆå›¾åƒçš„æ©ç ï¼Œå…¶å¯¹åº”çš„åƒç´ æ ‡ç­¾ä¸º0ã€‚å¦‚æœæ ‡ç­¾ä¸ºcompositeï¼ˆ0ï¼‰ï¼Œåˆ™æ•°æ®é¡¹æƒ©ç½šä¸º0ï¼Œä¹˜ä»¥`scale`åè¿˜æ˜¯0ã€‚
- å½“æ ‡ç­¾ä¸åŒ¹é…æ—¶ï¼Œæƒ©ç½šæ˜¯ä¸€ä¸ªéå¸¸å¤§çš„å€¼`scale`ã€‚

é€šè¿‡ä»¥ä¸Šä¸¤ä¸ªæƒ©ç½šé¡¹ï¼Œç®—æ³•èƒ½å¤Ÿåœ¨å›¾å‰²è¿‡ç¨‹ä¸­åˆç†åœ°å¹³è¡¡åƒç´ ä¹‹é—´çš„é¢œè‰²ç›¸äº’ä½œç”¨å’ŒæŒ‡å®šå›¾åƒæ•°æ®çš„çº¦æŸï¼Œä»è€Œå¾—åˆ°æœ€ç»ˆçš„æ ‡ç­¾å›¾ï¼ˆlabel mapï¼‰

### 2.3 Gradient-domain Fusion

åˆ©ç”¨Graph-cut optimizationä¸­æè¿°çš„ç®—æ³•è¿›è¡Œæ±‚è§£ä¹‹åï¼Œæˆ‘ä»¬å¾—åˆ°æ¯ä¸ªåƒç´ çš„labelã€‚ä½†æ˜¯ç”±äºå…‰ç…§ä¸åŒç­‰é—®é¢˜çš„å­˜åœ¨ï¼Œå¯èƒ½å¯¼è‡´åœ¨å›¾åƒçš„è¿æ¥å¤„ä¾ç„¶å­˜åœ¨æ˜æ˜¾çš„ç‘•ç–µã€‚æ‰€ä»¥è¿™é‡Œåšçš„æ˜¯å‡å°‘è¿™ç§ç‘•ç–µã€‚

å¯¹äºè®¸å¤šåº”ç”¨ç¨‹åºæ¥è¯´ï¼Œå›¾å‰²æœ¬èº«å¯èƒ½æ— æ³•äº§ç”Ÿè§†è§‰ä¸Šæ— ç¼çš„åˆæˆç»“æœï¼Œå› ä¸ºæºå›¾åƒä¹‹é—´çš„å·®å¼‚å¤ªå¤§ã€‚å¦‚æœå›¾å‰²ä¼˜åŒ–æ— æ³•æ‰¾åˆ°ç†æƒ³çš„æ¥ç¼çº¿ï¼Œä»å¯èƒ½å­˜åœ¨ä¼ªå½±ã€‚

åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œå°†è¾“å…¥å›¾åƒè§†ä¸ºé¢œè‰²æ¢¯åº¦çš„æ¥æºè€Œä¸æ˜¯é¢œè‰²çš„æ¥æºæ˜¯æœ‰ç”¨çš„ã€‚ä½¿ç”¨ç›¸åŒçš„å›¾å‰²æ ‡ç­¾ï¼Œæˆ‘ä»¬å¤åˆ¶é¢œè‰²æ¢¯åº¦ä»¥å½¢æˆä¸€ä¸ªå¤åˆçŸ¢é‡åœºã€‚ç„¶åï¼Œæˆ‘ä»¬è®¡ç®—ä¸€ä¸ªé¢œè‰²å¤åˆå›¾åƒï¼Œå…¶æ¢¯åº¦æœ€èƒ½åŒ¹é…è¯¥çŸ¢é‡åœºã€‚é€šè¿‡è¿™æ ·åšï¼Œæˆ‘ä»¬å¯ä»¥å¹³æ»‘ç›¸é‚»å›¾åƒåŒºåŸŸä¹‹é—´çš„é¢œè‰²å·®å¼‚ã€‚æˆ‘ä»¬å°†è¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºæ¢¯åº¦åŸŸèåˆã€‚é™¤éæ¢¯åº¦åœºæ˜¯ä¿å®ˆçš„ï¼Œå¦åˆ™ä¸å­˜åœ¨ä¸€ä¸ªæ¢¯åº¦å®Œå…¨åŒ¹é…è¾“å…¥çš„å›¾åƒã€‚ç›¸åï¼Œå¯ä»¥é€šè¿‡æ±‚è§£Poissonæ–¹ç¨‹çš„ç¦»æ•£åŒ–æ¥è®¡ç®—æœ€ä½³æ‹Ÿåˆå›¾åƒï¼Œå³åœ¨æœ€å°äºŒä¹˜æ„ä¹‰ä¸‹ã€‚

å¯¹äºå•ä¸ªé¢œè‰²é€šé“ï¼Œæˆ‘ä»¬å¯»æ±‚è§£åƒç´ å€¼$I(x, y)$ã€‚æˆ‘ä»¬å°†è¿™äº›å€¼é‡æ–°æ’åºä¸ºä¸€ä¸ªå‘é‡$v$ï¼Œä½†ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬ä»ç„¶æ ¹æ®å…¶å¯¹åº”çš„$(x, y)$åƒç´ åæ ‡æ¥å¼•ç”¨æ¯ä¸ªå…ƒç´ $v_{x,y}$ã€‚è¾“å…¥æ¢¯åº¦$âˆ‡I(x, y)$æŒ‡å®šäº†ä¸¤ä¸ªæ¶‰åŠä¸¤ä¸ªå˜é‡çš„çº¿æ€§æ–¹ç¨‹ï¼š
$$
v_{x+1,y}-v_{x,y}=\nabla I_x(x,y)\\
v_{x,y+1}-v_{x,y}=\nabla I_y(x,y)
$$
æˆ‘ä»¬ä½¿ç”¨Numannè¾¹ç•Œæ¡ä»¶ï¼Œç›¸å½“äºå»é™¤æ¶‰åŠå›¾åƒè¾¹ç•Œå¤–åƒç´ çš„ä»»ä½•æ–¹ç¨‹ã€‚æ­¤å¤–ï¼Œç”±äºæ¢¯åº¦æ–¹ç¨‹åªèƒ½å®šä¹‰våŠ ä¸Šä¸€ä¸ªå¯åŠ å¸¸æ•°ï¼Œæˆ‘ä»¬è¦æ±‚ç”¨æˆ·é€‰æ‹©ä¸€ä¸ªåƒç´ ï¼Œå…¶é¢œè‰²å°†å—é™äºå…¶æºå›¾åƒä¸­çš„é¢œè‰²ï¼Œç„¶åå°†æ­¤çº¦æŸæ·»åŠ åˆ°çº¿æ€§ç³»ç»Ÿä¸­ã€‚

å½“åœ¨å…·æœ‰æ²¿é«˜æ¢¯åº¦è¾¹ç¼˜çš„æ¥ç¼æˆæœ¬ä¸­ä½¿ç”¨æ¢¯åº¦åŸŸèåˆæ—¶ï¼Œå¯èƒ½ä¼šå‡ºç°é¢å¤–çš„å¤æ‚æ€§ã€‚ç”±äºå¼ºè¾¹ç¼˜å¯èƒ½ä¼šè¢«æ··åˆæ‰ï¼Œè·¨è¶Šè¿™äº›æ¥ç¼çš„æ··åˆå¯èƒ½ä¼šäº§ç”Ÿä»¤äººä¸æ»¡æ„çš„æ¨¡ç³Šä¼ªå½±ã€‚æˆ‘ä»¬é€šè¿‡ç®€å•åœ°åœ¨è¾¹ç¼˜å¼ºåº¦ï¼ˆç”±Sobelç®—å­æµ‹é‡ï¼‰è¶…è¿‡ä¸€å®šé˜ˆå€¼çš„ä½ç½®æ”¾å¼ƒçº¿æ€§çº¦æŸæ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚

æ ¹æ®2.2ä¸­å¾—åˆ°çš„labelingï¼Œå»è®¡ç®—èåˆå›¾åƒä¸­çš„æ¯ä¸ªåƒç´ çš„æ¢¯åº¦ï¼Œç„¶åæ±‚è§£æ³Šæ¾æ–¹ç¨‹æ¥å¾—åˆ°æœ€ç»ˆçš„èåˆå›¾åƒæ¯ä¸ªåƒç´ çš„é¢œè‰², æˆ‘ä»¬å°±å¯ä»¥å¾—åˆ°æœ€åçš„å›¾ç‰‡äº†ã€‚ä»¥ä¸‹æ˜¯ä»£ç å®ç°

#### 2.3.1 Laplacian çŸ©é˜µç”Ÿæˆ

é¦–å…ˆï¼Œå®šä¹‰äº†ä¸€ä¸ªå‡½æ•°`laplacian_matrix`ï¼Œç”Ÿæˆç¦»æ•£æ³Šæ¾æ–¹ç¨‹çš„ç³»æ•°çŸ©é˜µç”±äºåç»­çš„æ³Šæ¾æ–¹ç¨‹æ±‚è§£, è¿™ä¸ªçŸ©é˜µç”¨æ¥è¡¨ç¤ºç¦»æ•£çš„æ‹‰æ™®æ‹‰æ–¯ç®—å­ï¼š

```python
def laplacian_matrix(n, m):
    """
    Generate the Poisson matrix.
    """
    # Create the main diagonal
    main_diag = 4 * sp.eye(m, format='lil')

    # Create the diagonals for the -1s within each block
    off_diag_1 = -1 * sp.eye(m, k=1, format='lil')
    off_diag_2 = -1 * sp.eye(m, k=-1, format='lil')

    # Combine the diagonals within each block
    mat_D = main_diag + off_diag_1 + off_diag_2

    # Create the block diagonal matrix for all blocks
    mat_A = sp.block_diag([mat_D] * n, format='lil')

    # Add the off-diagonal blocks
    for i in range(n - 1):
        mat_A[i * m:(i + 1) * m, (i + 1) * m:(i + 2) * m] = -1 * sp.eye(m, format='lil')
        mat_A[(i + 1) * m:(i + 2) * m, i * m:(i + 1) * m] = -1 * sp.eye(m, format='lil')

    return mat_A
```

#### 2.3.2 æ³Šæ¾å›¾åƒç¼–è¾‘å‡½æ•°

å¥½çš„ï¼Œæˆ‘ä»¬æŒ‰ç…§ç±»ä¼¼æ–‡æœ¬çš„æ–¹å¼è¯¦ç»†è§£æ`poisson_edit`å‡½æ•°ï¼Œå®ç°æ³Šæ¾å›¾åƒç¼–è¾‘, å…·ä½“å®ç°å‚è€ƒäº†è®ºæ–‡ [Poisson image editing](https://www.ipol.im/pub/pre/163/) å’Œå®ƒçš„[åŸå§‹code](https://github.com/PPPW/poisson-image-editing)ã€‚

å…·ä½“çš„å®ç°ä¸º`poisson.py`æ–‡ä»¶ä¸­çš„`poisson_edit`å‡½æ•°

**åˆå§‹åŒ–**

```python
    y_max, x_max = target.shape[:-1]
    y_min, x_min = 0, 0
    x_range = x_max - x_min
    y_range = y_max - y_min
```

è¿™ä¸€æ­¥ä¸»è¦æ˜¯è®¡ç®—è·å–ç›®æ ‡å›¾åƒçš„å®½åº¦ `x_max` å’Œé«˜åº¦ `y_max`ï¼Œå¹¶è®¡ç®—èŒƒå›´ `x_range` å’Œ `y_range`

```python
    M = np.float32([[1, 0, offset[0]], [0, 1, offset[1]]])
    source = cv2.warpAffine(source, M, (x_range, y_range))
```

åˆ›å»ºä»¿å°„å˜æ¢çŸ©é˜µ `M`ï¼Œç”¨äºæ ¹æ® `offset` å¯¹æºå›¾åƒè¿›è¡Œå¹³ç§», å¹¶ä¸”ä½¿ç”¨ `cv2.warpAffine` åº”ç”¨å˜æ¢ï¼Œå°†æºå›¾åƒå¹³ç§»åˆ°ç›®æ ‡å›¾åƒçš„å¯¹é½ä½ç½®ã€‚

```python
    mask = mask[y_min:y_max, x_min:x_max]
    mask = (mask != 0).astype(np.uint8)
```

å¯¹æ©ç è¿›è¡Œè£å‰ªï¼Œä½¿å…¶ä¸ç›®æ ‡å›¾åƒçš„å¤§å°ä¸€è‡´ï¼Œç„¶åå†å°†æ©ç äºŒå€¼åŒ–ï¼Œå³æ©ç ä¸­éé›¶å€¼è®¾ä¸º1ï¼Œé›¶å€¼è®¾ä¸º0ã€‚

**ç”Ÿæˆæ‹‰æ™®æ‹‰æ–¯çŸ©é˜µ**

```python
    mat_A = laplacian_matrix(y_range, x_range).tolil()
    laplacian = mat_A.tocsc() # for \Delta g
```

è°ƒç”¨ `laplacian_matrix` å‡½æ•°ç”Ÿæˆæ³Šæ¾çŸ©é˜µ `mat_A`ï¼Œå¹¶å°† `mat_A` è½¬æ¢ä¸ºç¨€ç–åˆ—å‹ç¼©æ ¼å¼ (`csc`)ï¼Œæ–¹ä¾¿åç»­è®¡ç®—ã€‚

**è®¾ç½®è¾¹ç•Œæ¡ä»¶**

```python
    for y in range(1, y_range - 1):
        for x in range(1, x_range - 1):
            if mask[y, x] == 0:
                k = x + y * x_range
                mat_A[k, k] = 1
                mat_A[k, k + 1] = 0
                mat_A[k, k - 1] = 0
                mat_A[k, k + x_range] = 0
                mat_A[k, k - x_range] = 0
    mat_A = mat_A.tocsc()
```

é€šè¿‡å¾ªç¯ï¼Œå°†æ©ç å¤–çš„åŒºåŸŸè®¾ç½®ä¸ºå•ä½çŸ©é˜µï¼Œå¯¹äºæ©ç å¤–çš„åƒç´ ï¼Œä¿æŒå…¶é¢œè‰²å€¼ä¸å˜ã€‚

**æ³Šæ¾æ–¹ç¨‹æ±‚è§£**

```python
    mask_flat = mask.flatten()
    for channel in range(source.shape[2]):
        source_flat = source[y_min:y_max, x_min:x_max, channel].flatten()
        target_flat = target[y_min:y_max, x_min:x_max, channel].flatten()
        mat_b = laplacian.dot(source_flat) * 1 # alpha = 1
        mat_b[mask_flat==0] = target_flat[mask_flat==0]
        x = spsolve(mat_A, mat_b)
        x = x.reshape((y_range, x_range))

        x[x > 255] = 255
        x[x < 0] = 0
        x = x.astype('uint8')
        target[y_min:y_max, x_min:x_max, channel] = x

    return target
```

- å°†æ©ç å±•å¹³ä¸ºä¸€ç»´å‘é‡ `mask_flat`ã€‚
- å¯¹äºæ¯ä¸ªé¢œè‰²é€šé“ï¼š
  - å°†æºå›¾åƒå’Œç›®æ ‡å›¾åƒçš„ç›¸åº”é€šé“å±•å¹³ä¸ºä¸€ç»´å‘é‡ `source_flat` å’Œ `target_flat`ã€‚
  - è®¡ç®—æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µä½œç”¨äºæºå›¾åƒå¾—åˆ°çš„å‘é‡ `mat_b`ã€‚
  - åœ¨æ©ç å¤–åŒºåŸŸï¼Œå°† `mat_b` è®¾ç½®ä¸ºç›®æ ‡å›¾åƒçš„å€¼ã€‚
  - ä½¿ç”¨ `spsolve` æ±‚è§£çº¿æ€§ç³»ç»Ÿï¼Œå¾—åˆ°èåˆåçš„é¢œè‰²å€¼ `x`ã€‚
  - å°†èåˆåçš„å€¼é™åˆ¶åœ¨0åˆ°255ä¹‹é—´ï¼Œå¹¶è½¬æ¢ä¸º `uint8` ç±»å‹ã€‚
  - æ›´æ–°ç›®æ ‡å›¾åƒçš„ç›¸åº”é€šé“ã€‚

é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬å®ç°äº†åŸºäºæ³Šæ¾æ–¹ç¨‹çš„å›¾åƒèåˆï¼Œå‡å°‘äº†å›¾åƒè¿æ¥å¤„çš„ç‘•ç–µï¼Œå¾—åˆ°äº†æ›´å¹³æ»‘çš„åˆæˆæ•ˆæœã€‚

## ä¸‰ã€GUIå®ç°

gradioç‰ˆæœ¬4.9.0å’ŒPyQTéƒ½ä¼šå¯¼è‡´æŸäº›åŠŸèƒ½æ— æ³•æ˜¾ç¤ºï¼ˆå“ï¼Œpythonçš„GUIè¿˜æ˜¯æ²¡æœ‰ç›´æ¥å†™htmlçš„åŠŸèƒ½ä¸°å¯ŒğŸ˜‚ï¼‰

==è¿™éƒ¨åˆ†è¦é‡å†™ï¼Œç„¶ååˆ†æä¸‹ä»£ç ==

æˆ‘å®ç°çš„é…è‰²ä¹Ÿä»¿ç…§äº†åŸè®ºæ–‡çš„é…è‰²ğŸ˜œ

## å››ã€æ•ˆæœæ¼”ç¤º

åœ¨ä¸åŠ©æ•™æ²Ÿé€šç¡®è®¤åï¼Œæˆ‘ä½¿ç”¨äº†pythonå®Œæˆäº†æ‰€æœ‰ç¨‹åºçš„å®ç°ï¼Œä¸‹åˆ—æ¼”ç¤ºç¨‹åºæ•ˆæœã€‚

### 3.1 Gradient-domain Fusion

æˆ‘é¦–å…ˆå¯¹Gradient-domain Fusionçš„æ•ˆæœè¿›è¡Œçš„æµ‹è¯•ï¼Œä¿è¯æ³Šæ¾æ–¹ç¨‹æ±‚è§£çš„æ­£ç¡®æ€§ã€‚

æµ‹è¯•ä»£ç å¦‚ä¸‹ï¼š

```python
def poisson_edit_from_path(source, target, mask=None, offset=(0,0)):
    '''
    test poisson edit function
    '''
    source = np.array(Image.open(source).convert('RGB'))
    target = np.array(Image.open(target).convert('RGB'))
    if mask is None:
        # ä¸ŠåŠéƒ¨åˆ†ä¸º1ï¼Œä¸‹åŠéƒ¨åˆ†ä¸º0. æœ€ç»ˆç»“æœä¸ºä¸ŠåŠéƒ¨åˆ†ä¸ºsourceçš„å›¾åƒï¼Œä¸‹åŠéƒ¨åˆ†ä¸ºtargetçš„å›¾åƒ
        mask = np.ones_like(source[:, :, 0])
        mask[source.shape[0] // 2:, :] = 0
    else:
        mask = np.array(Image.open(mask).convert('L'))
    result = poisson_edit(source, target, mask, offset)
    return result

if __name__ == '__main__':
    scr_dir = 'source_imgs'
    res = poisson_edit_from_path(path.join(scr_dir, "famille1.jpg"),
                                 path.join(scr_dir, "famille2.jpg"))
    Image.fromarray(res).save('test_poission.jpg')
```

æœ€åçš„æµ‹è¯•æ•ˆæœå¦‚ä¸‹ï¼š

<img src="fig/03.png"/>

å› ä¸ºæˆ‘èåˆçš„maskä¸ºä¸ŠåŠéƒ¨åˆ†å–ç¬¬ä¸€å¼ å›¾ï¼Œä¸‹åŠéƒ¨åˆ†å–ç¬¬äºŒå¼ å›¾ã€‚å¯ä»¥å‘ç°é™¤äº†æœ€å³ä¾§çš„ç”±äºå¹…åº¦å®åœ¨å¤ªå¤§ï¼Œèåˆçš„æ•ˆæœè¾ƒå·®å¤–ï¼Œå…¶ä½™çš„èåˆæ•ˆæœéƒ½åœ¨å¯ä»¥æ¥å—çš„èŒƒå›´å†…

### 3.2 ä»»æ„ä¸¤å¼ å›¾ç‰‡çš„äº¤äº’å¼è’™å¤ªå¥‡

è¿™é‡Œæˆ‘å°†å±•ç¤ºæˆ‘å®ç°çš„äº¤äº’å¼è’™å¤ªå¥‡ç®—æ³•çš„æ­£ç¡®æ€§å’Œå±•ç¤ºæˆ‘å®ç°çš„bonusæ•ˆæœï¼Œå…·ä½“æ¥è¯´æˆ‘å®ç°äº†bonus:



todo:  å¤šå›¾çš„maskæ³¨æ„ä¸€ä¸‹

å•ç¬”çš„ æŠŠmaskçš„è¿”å›æ¥å£æ³¨æ„ä¸€ä¸‹ï¼Œç„¶åè’™å¤ªå¥‡çš„pä¸‹å›¾ç®—äº†(ç”¨é‚£ä¸ªç¬”åˆ·åšä¸€ä¸‹)



configè™½ç„¶æ¢æˆ400ï¼Œ300ä¹Ÿæ²¡é—®é¢˜ï¼Œä½†æ˜¯è¿˜æ˜¯ä¸æäº†



<font color='red'>1. ä½¿ç”¨é¼ æ ‡è¿›è¡Œäº¤äº’ï¼Œå®ç°ç®€å•çš„ç”»åˆ·</font>

<font color='red'>2. èƒ½å¤Ÿé€šè¿‡å›¾åƒå·ç é€‰æ‹©éœ€è¦äº¤äº’çš„å›¾åƒ</font>

ä¿®æ”¹configï¼Œç„¶åæŒ‰ç…§configä¸‹çš„æ–‡ä»¶æ•°é‡è¿›è¡Œå±•ç¤º

<font color='red'>3. å®ç°å•ä¸€å›¾åƒç¬”åˆ·åŠŸèƒ½ã€‚ä½¿ç”¨å•ä¸ªå›¾åƒç¬”åˆ·ï¼Œç”¨æˆ·å¸Œæœ›åªå‘å½“å‰åˆæˆä¸­æ·»åŠ ä¸€ä¸ªå›¾åƒï¼Œå¹¶ä¸”è¯¥å›¾åƒåº”è¯¥æ˜¯æ—¢æ»¡è¶³ç¬”åˆ’ä¸‹çš„ç›®æ ‡åˆå°½å¯èƒ½æ— ç¼åœ°ä¸ç°æœ‰åˆæˆåŒ¹é…çš„æœ€ä½³å›¾åƒã€‚ä¸ºäº†å‘ç”¨æˆ·æä¾›å¯¹æœ€ä½³å›¾åƒé€‰æ‹©çš„æ§åˆ¶ï¼Œåœ¨ç»˜åˆ¶ä¹‹åç«‹å³å‘ç”¨æˆ·æ˜¾ç¤ºç¬¬ä¸‰ä¸ªçª—å£ï¼Œç§°ä¸ºé€‰æ‹©çª—å£</font> ==è¿™ä¸ª3æˆ‘å¥½åƒæ²¡å®ç°== è¿™ä¸ªç›´æ¥æ”¹ä¸ºç”¨SAMå§ï¼Œå¤šä¸ªæŒ‰é’®è°ƒç”¨SAMç›´æ¥å¤„ç†ä¸‹ã€‚ç„¶åç”¨ç”»ç¬”é€‰ä¸­çš„åŒºåŸŸçš„ä¸œè¥¿ç›´æ¥åˆ‡å‡ºæ¥

### 3.3 å¤šå›¾è’™å¤ªå¥‡

è¿™é‡Œå®ç°çš„ä»¥ä¸‹bonus:

> å®ç°å¤šå›¾åƒç¬”åˆ·çš„åŠŸèƒ½ã€‚å¤šå›¾åƒç¬”åˆ·ä¸»è¦é’ˆå¯¹ä¸€ä¸ªå›¾åƒä¸åŒ…å«æ‰€æœ‰éœ€è¦çš„æ•ˆæœæƒ…å†µä¸‹çš„æƒ…æ™¯ï¼ˆæœ€å¤š2åˆ†ï¼‰

å¤§è‡´çš„æµç¨‹ä¸ºä¸¤ä¸¤ä¹‹é—´å®ç°è’™å¤ªå¥‡ï¼Œç„¶ååŠ¨æ€å¾—æ›´æ–°æ ‡ç­¾å›¾ï¼Œå¹¶ä¸”ç´¯è®¡`mask`åŒºåŸŸ, ä¸»è¦çš„å‡½æ•°å¦‚ä¸‹:

```python
def run_multi(source_input_1, source_input_2, source_input_3, source_input_4):
    source_inputs = [source_input_1, source_input_2, source_input_3, source_input_4]

    # mask: (h, w)
    source_mask_list = [process_mask(s, fixed_width=FIXED_WIDTH, fixed_height=FIXED_HEIGHT)[:, :, 0] for s in source_inputs]
    label_map = np.zeros((FIXED_HEIGHT, FIXED_WIDTH), dtype=np.int64)
    composite_image = None
    label_map_image = None
    histrory_mask = None
    for idx in tqdm(range(len(source_inputs)-1)): # ä»0å¼€å§‹
        if composite_image is None:
            composite_image = source_inputs[0]['image']
        if histrory_mask is None:
            assert idx == 0
            histrory_mask = source_mask_list[idx]
        else:
            histrory_mask = np.logical_or(histrory_mask, source_mask_list[idx])
            histrory_mask = np.logical_and(histrory_mask, np.logical_not(source_mask_list[idx + 1]))
        binary_map = alpha_beta_swap(composite=np.array(composite_image),
                                     source=np.array(np.array(source_inputs[idx+1]['image'])),
                                     composite_mask=histrory_mask, source_mask=source_mask_list[idx+1])
        label_map = update_label_map(label_map, binary_map, idx+1)
        label_map_image = show_label_map(label_map)
        composite_image = create_composite(binary_map=binary_map, source=np.array(source_inputs[idx+1]['image']),
                                       target=np.array(composite_image))
        # ä¿å­˜ä¹‹é—´çš„è¿‡ç¨‹å›¾
        composite_image.save(f"test/multi/image_{idx}.jpg")
        label_map_image.save(f"test/multi/label_{idx}.jpg")
    return composite_image, label_map_image
```

å¤§è‡´æ•ˆæœå¦‚ä¸‹

å…¶ä»”ç»†è§‚å¯Ÿï¼Œæˆ‘çš„ç”»ç¬”æ‰€è½çš„ä½ç½®ï¼Œå¯ä»¥å‘ç°æˆ‘è¦æ±‚æ¶‚æŠ¹çš„åŒºåŸŸåœ¨ä¸‹åˆ—ä¾‹å­ä¸­éƒ½æœ‰æ‰€ä½“ç°

case1ï¼š

![](fig/case1.png)

case2ï¼š

![](fig/case2.png)

##### é‡åˆ°çš„bugåˆ†æ

éœ€è¦é¢å¤–æ³¨æ„çš„æ˜¯ `histrory_mask`éœ€è¦ä¸€ä¸ªä¸å½“å‰`mask`çš„éçš„ä¸çš„è¿‡ç¨‹

```python
histrory_mask = np.logical_or(histrory_mask, source_mask_list[idx])
```

å¦åˆ™ä¼šå‡ºç°ä»¥ä¸‹é—®é¢˜ï¼Œå¯ä»¥å‘ç°æ©™è‰²çš„åŒºåŸŸä¸€ç›´è¢«å æ®äº†

![](fig/case3.png)

## äº”ã€å‚è€ƒæ–‡çŒ®

[1] Agarwala A, Dontcheva M, Agrawala M, et al. Interactive digital photomontage[M]//ACM SIGGRAPH 2004 Papers. 2004: 294-302.

[2] Vladimir Kolmogorov, Ramin Zabih: What Energy Functions Can Be Minimized via Graph Cuts? IEEE Trans. Pattern Anal. Mach. Intell. 26(2): 147-159

[3]  Gao J, Li Y, Chin T J, et al. Seam-driven image stitching[C]//Eurographics (Short Papers). 2013: 45-48.

[4]  Aqrawi A A, Boe T H. Improved fault segmentation using a dip guided and modified 3D Sobel filter[M]//SEG Technical Program Expanded Abstracts 2011. Society of Exploration Geophysicists, 2011: 999-1003.

[5] Kohli P, Torr P H S. Efficiently solving dynamic markov random fields using graph cuts[C]//Tenth IEEE International Conference on Computer Vision (ICCV'05) Volume 1. IEEE, 2005, 2: 922-929.

[6] Di Martino J M, Facciolo G, Meinhardt-Llopis E. Poisson image editing[J]. Image Processing On Line, 2016, 6: 300-325.

# äº¤ä½œä¸š

æºä»£ç å’Œé¡¹ç›®æŠ¥å‘Šæäº¤æˆªæ­¢æ—¶é—´ï¼šæš‚å®šä¸º 2024å¹´6æœˆ16æ—¥23:59ï¼Œ å¦‚æœ‰å˜åŒ–å¦è¡Œé€šçŸ¥ã€‚

æäº¤æ–¹å¼ï¼šæŠ¥å‘Šå’Œæºä»£ç æ‰“åŒ…æäº¤è‡³å­¦åœ¨æµ™å¤§ã€‚

å‘½åæ–¹å¼ï¼šfinal-é¡¹ç›®å-å­¦å·-å§“å.zip
